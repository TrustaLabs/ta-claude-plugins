# Trusta Claude 插件集合

Trusta 通用 Claude Code 插件集合，提供多种实用功能来增强开发体验。

## 包含的插件

### 1. 交互式计划制定 (Interactive Planning)

通过交互式多轮对话帮助创建详细、可执行的实施计划。

### 2. 团队知识上下文系统 (Team Context)

让 AI 研发助手了解和应用团队的编码规范、架构设计、业务知识和工作流程。

## 功能特性

- **5层次需求框架**：系统化地挖掘需求全貌（Why/What/How/Constraints/EdgeCases）
- **MoSCoW 范围确认**：明确功能优先级，防止需求跑偏
- **4维度边界情况矩阵**：系统化处理边界情况（数据/网络/并发/权限）
- **高效对话流程**：3-5轮灵活调整，减少反复对话，提高信息密度
- **技术权衡分析**：对比多种技术方案，帮助做出明智决策
- **风险评估**：识别潜在风险并提供缓解措施
- **测试策略**：设计全面的测试方案
- **文档驱动**：自动生成结构化的计划文档

## 安装

TODO

## 使用方法

### 方法 1：使用 /ta-plan 命令（推荐）

直接使用 slash command 启动计划制定流程：

```bash
/ta-plan [可选：功能描述]
```

**示例：**
```bash
/ta-plan 添加用户认证功能
/ta-plan 实现深色模式
/ta-plan
```

### 方法 2：自然语言触发 Skill

当你需要制定实施计划时，也可以使用以下任何一种表达方式：

- "帮我制定实现计划"
- "创建开发计划"
- "分析需求并设计方案"
- "评估技术方案"
- "我需要一个详细的实施计划"
- "交互式制定计划"

### 使用流程

**核心3轮流程（简单功能）：**

1. **第1轮：需求全貌挖掘（15-20分钟）**
   - 使用5层次框架深度澄清需求（Why/What/How/Constraints/EdgeCases）
   - 使用 MoSCoW 矩阵确认范围（Must/Should/Could/Won't Have）
   - 输出：需求概述 + 范围矩阵

2. **第2轮：方案设计与细化（20-30分钟）**
   - 技术方案评估和权衡
   - 实施步骤分解（具体任务、文件路径、依赖关系）
   - 4维度边界情况矩阵（数据/网络/并发/权限）
   - 输出：技术方案 + 实施步骤 + 边界情况处理

3. **第3轮：风险测试与最终审查（15-20分钟）**
   - 风险评估和缓解措施
   - 测试策略（单元/集成/E2E）
   - 最终完整性检查
   - 输出：完整的实施计划文档

**扩展5轮流程（复杂功能）：**

当功能复杂时（多个技术方案、高风险、多模块），可扩展为5轮：
- 第1轮：需求全貌挖掘
- 第2轮：技术方案评估
- 第3轮：实施路径规划
- 第4轮：风险和边界情况
- 第5轮：测试策略与最终审查

**核心优势：**
- ✅ 减少对话轮次，提高效率
- ✅ 每轮信息密度高，一次收集更多信息
- ✅ 仅在关键点确认（范围、技术方案、最终审查）

## 示例

### 示例 1：简单功能（3轮对话）

```
用户：帮我制定一个添加"记住我"功能的计划

Skill：
第1轮：询问功能细节（存储方式、过期时间等）
第2轮：细化实施步骤（修改哪些文件、添加什么代码）
第3轮：最终审查并输出计划
```

### 示例 2：复杂功能（5-7轮对话）

```
用户：我需要实现一个完整的用户认证系统

Skill：
第1轮：澄清需求（支持哪些登录方式、安全要求等）
第2轮：细化方案（分阶段实施、具体任务）
第3轮：技术权衡（JWT vs Session、状态管理方案）
第4轮：补充边缘情况（错误处理、性能优化）
第5轮：最终审查（完整性检查、可执行性验证）
```

## 输出文档结构

计划文档保存在 `docs/plans/[功能名称]-[时间戳].md`，包含：

1. **需求概述** - 背景、目标、范围、成功标准
2. **技术方案** - 架构、技术选型、数据模型、API 设计
3. **实施步骤** - 分阶段的具体任务，包含文件路径
4. **风险评估** - 识别风险、评估影响、缓解措施
5. **测试策略** - 单元测试、集成测试、E2E 测试
6. **技术权衡** - 方案对比、决策理由
7. **回滚计划** - 回滚条件、步骤、数据备份
8. **后续工作** - 已知限制、未来改进

## 支持文件

### 参考文档

- **`references/planning-best-practices.md`** - 详细的计划方法论、风险评估框架、迭代细化策略

### 示例模板

- **`examples/plan-template.md`** - 完整的计划文档模板，可直接复制使用

## 与项目集成

### 与 TDD 流程集成

计划批准后，Skill 会提醒你遵循 TDD 流程：
1. 先写测试（Red）
2. 实现代码（Green）
3. 重构（Refactor）

### 与项目文档集成

Skill 会参考项目的 `CLAUDE.md` 和其他文档：
- `docs/ARCHITECTURE.md` - 了解项目架构
- `docs/TESTING.md` - 遵循测试规范
- `docs/THEME_USAGE.md` - 遵循样式规范

## 配置

### 自定义输出目录

默认输出到 `docs/plans/`，可以在使用时指定其他目录。

### 调整对话轮数

Skill 会根据计划复杂度自动调整对话轮数（3-7轮），你也可以在任何时候：
- 要求跳过某些轮次
- 要求增加额外的讨论轮次
- 直接进入最终审查

## 最佳实践

1. **提供充分的上下文** - 越详细的背景信息，计划越准确
2. **积极参与对话** - 认真回答每轮的问题，提供反馈
3. **保存计划文档** - 将计划文档提交到版本控制
4. **定期更新计划** - 实施过程中发现问题时更新计划
5. **参考历史计划** - 查看之前的计划文档作为参考

## 故障排除

### Skill 没有触发

确保你的表达包含关键词：
- "制定计划"、"创建计划"
- "分析需求"、"设计方案"
- "评估方案"、"优化计划"

### 计划文档未生成

检查 `.claude/plans/` 目录是否存在，如果不存在会自动创建。

### 对话轮数不合适

可以明确告诉 Skill：
- "这个功能比较简单，3轮就够了"
- "这个功能很复杂，我们需要更详细的讨论"

## 版本历史

- **v0.2.1** (2024-12-25)
  - ✨ 新增 `/ta-plan` 命令，支持直接调用 skill
  - 📝 更新使用方法，推荐使用 command 方式

- **v0.2.0** (2024-12-25)
  - ✨ 新增5层次需求框架（Why/What/How/Constraints/EdgeCases）
  - ✨ 新增 MoSCoW 范围确认机制，防止需求跑偏
  - ✨ 新增4维度边界情况矩阵（数据/网络/并发/权限）
  - ⚡ 优化对话流程：从固定5轮改为灵活3-5轮
  - ⚡ 提高信息密度，减少反复对话
  - 📝 扩展 references/planning-best-practices.md（新增600+行）
  - 📝 更新 examples/plan-template.md，添加 MoSCoW 章节

- **v0.1.0** (2024-12-24)
  - 初始版本
  - 支持 3-7 轮交互式对话
  - 自动生成结构化计划文档
  - 包含风险评估和测试策略

## 贡献

欢迎提出改进建议！

---

## 团队知识上下文系统

### 功能概述

团队知识上下文系统让 AI 能够自动了解和应用你的团队规范，包括：
- **编码规范**：命名约定、函数设计、错误处理
- **架构设计**：技术栈、目录结构、API 设计
- **业务知识**：核心概念、业务规则
- **工作流程**：Git 工作流、代码审查、发布流程

### 核心优势

- ✅ **自动应用规范**：AI 生成的代码自动符合团队标准
- ✅ **减少重复解释**：无需每次都说明团队规范
- ✅ **新人快速上手**：通过 AI 快速了解团队约定
- ✅ **知识集中管理**：单一信息源，易于维护

### 快速开始

#### 1. 自定义团队知识

编辑 `docs/team-context.md` 文件，替换为你的团队实际规范：

```bash
# 编辑知识文件
vim docs/team-context.md

# 更新内容：
# - 技术栈
# - 业务术语
# - 编码规范
# - 工作流程
```

#### 2. 使用 Skill 加载知识

在 Claude Code 中使用 `/load-context` 命令：

```bash
# 加载所有知识
/load-context

# 按需加载
/load-context --type coding-standards
/load-context --type architecture
/load-context --type business
/load-context --type workflow

# 组合加载
/load-context --type coding-standards,architecture
```

#### 3. 验证效果

加载知识后，请求 AI 生成代码：

```
请创建一个用户服务类，包含 CRUD 操作
```

AI 会自动应用你的团队规范！

### 使用场景

#### 场景 1：代码生成

```bash
/load-context --type coding-standards,architecture
"请创建一个登录表单组件"
```

#### 场景 2：代码审查

```bash
/load-context --type coding-standards
"请审查 src/services/userService.ts 是否符合规范"
```

#### 场景 3：业务逻辑

```bash
/load-context --type business
"请实现订单创建的业务逻辑"
```

#### 场景 4：新人学习

```bash
/load-context
"团队的 Git 工作流是什么?"
```

### 知识文件结构

`docs/team-context.md` 包含以下章节：

```markdown
## 1. 编码规范
### 1.1 命名约定
### 1.2 函数设计
### 1.3 错误处理

## 2. 架构设计
### 2.1 技术栈
### 2.2 目录结构
### 2.3 API 设计

## 3. 业务知识
### 3.1 核心业务概念
### 3.2 业务规则

## 4. 工作流程
### 4.1 Git 工作流
### 4.2 代码审查
### 4.3 发布流程
```

每个规范包含：
- **原则**：简洁描述
- **正例**：好的代码示例
- **反例**：不好的代码示例（标记 ❌）

### 维护指南

#### 更新知识文件

```bash
# 1. 编辑知识文件
vim docs/team-context.md

# 2. 更新 last_updated 字段
# 3. 提交到 Git
git add docs/team-context.md
git commit -m "docs: update team context"
```

#### 版本管理

- **补丁版本（1.0.x）**：修正错误、补充示例
- **次版本（1.x.0）**：添加新章节、新规范
- **主版本（x.0.0）**：重大变更、架构调整

### 详细文档

- **快速开始**：`docs/quick-start.md` - 5 分钟快速上手
- **详细指南**：`docs/team-context-guide.md` - 完整的使用、维护和故障排除
- **使用示例**：`skills/load-context/examples/usage.md` - 6 个实际使用场景
- **实施计划**：`docs/plans/team-context-system-20251226.md` - 完整的设计和实施文档

### 最佳实践

1. **按需加载**：只加载当前任务需要的知识类型
2. **任务开始前加载**：在请求 AI 之前先加载知识
3. **保持知识精简**：每个规范 <200 字，使用代码示例
4. **定期更新**：技术栈变化时更新，发现新的最佳实践时添加

### 常见问题

**Q: 知识文件可以拆分成多个文件吗？**
A: 可以，但当前推荐单文件管理（适合小团队）。如果知识量很大，可以按主题拆分。

**Q: 如何让 AI 自动应用规范，而不是每次手动加载？**
A: 可以使用 Hook 机制（见详细指南），在代码生成前自动注入规范。

**Q: 知识更新后需要重新加载吗？**
A: 是的，编辑 `team-context.md` 后需要重新运行 `/load-context`。

**Q: 会消耗很多 token 吗？**
A: 按需加载可以控制 token 消耗。建议只加载当前任务需要的知识类型。

