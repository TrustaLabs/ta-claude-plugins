# 计划制定最佳实践

本文档提供详细的计划方法论、风险评估框架和迭代细化策略，作为交互式计划制定 skill 的参考资料。

## 计划制定方法论

### 1. 自顶向下分解法

从高层目标开始，逐步分解为可执行的任务：

```
目标 → 功能模块 → 子功能 → 具体任务 → 代码文件
```

**示例：**
```
目标：实现用户认证系统
├── 功能模块1：用户注册
│   ├── 子功能：表单验证
│   │   ├── 任务：邮箱格式验证 (utils/validation.ts)
│   │   └── 任务：密码强度检查 (utils/validation.ts)
│   └── 子功能：API 集成
│       └── 任务：调用注册接口 (api/auth.ts)
└── 功能模块2：用户登录
    └── ...
```

### 2. 依赖关系分析

识别任务之间的依赖关系，确定实施顺序：

- **串行依赖**：任务 B 必须在任务 A 完成后才能开始
- **并行任务**：可以同时进行的独立任务
- **可选依赖**：理想情况下应该先完成，但不是强制的

**依赖关系图示例：**
```
A (数据模型定义)
├── B (API 接口实现) [依赖 A]
│   └── D (前端集成) [依赖 B]
└── C (数据库迁移) [依赖 A，可与 B 并行]
```

### 3. 迭代细化策略

每轮迭代应该：
- **增加细节层次**：从概念到具体实现
- **减少不确定性**：通过提问消除模糊
- **验证可行性**：确认技术方案可行
- **调整范围**：根据反馈调整计划边界

## 风险评估框架

### 风险识别矩阵

| 风险类型 | 识别问题 | 示例 |
|---------|---------|------|
| **技术风险** | 技术是否成熟？是否有经验？ | 使用新框架、复杂算法 |
| **依赖风险** | 是否依赖外部服务或库？ | 第三方 API、未维护的库 |
| **性能风险** | 是否可能影响性能？ | 大数据处理、复杂查询 |
| **安全风险** | 是否涉及敏感数据？ | 用户认证、支付信息 |
| **兼容性风险** | 是否需要支持多平台/浏览器？ | 跨浏览器、移动端适配 |
| **时间风险** | 任务是否可能超时？ | 复杂重构、大规模迁移 |

### 风险评估模板

对每个识别的风险，评估：

```markdown
**风险：** [风险描述]
**概率：** 高/中/低
**影响：** 高/中/低
**优先级：** 概率 × 影响
**缓解措施：**
- 预防措施：[如何降低概率]
- 应对措施：[如果发生如何处理]
- 备选方案：[Plan B]
```

### 风险优先级矩阵

```
影响 ↑
高 │ 中优先级 │ 高优先级 │ 高优先级
中 │ 低优先级 │ 中优先级 │ 高优先级
低 │ 低优先级 │ 低优先级 │ 中优先级
   └─────────┴─────────┴─────────→ 概率
      低        中        高
```

## 技术方案评估

### 方案对比框架

对每个候选方案，评估以下维度：

| 维度 | 评估标准 | 权重 |
|------|---------|------|
| **实现复杂度** | 代码量、学习曲线、维护成本 | 高 |
| **性能** | 响应时间、资源消耗、可扩展性 | 高 |
| **可维护性** | 代码清晰度、文档完整性、社区支持 | 中 |
| **兼容性** | 浏览器支持、依赖版本、向后兼容 | 中 |
| **安全性** | 已知漏洞、安全最佳实践、审计记录 | 高 |
| **成本** | 开发时间、第三方服务费用、运维成本 | 中 |

### 决策矩阵示例

**场景：选择状态管理方案**

| 方案 | 实现复杂度 | 性能 | 可维护性 | 学习曲线 | 总分 | 推荐 |
|------|-----------|------|---------|---------|------|------|
| Redux | 3/5 | 5/5 | 4/5 | 2/5 | 14/20 | ❌ |
| Context API | 5/5 | 4/5 | 4/5 | 5/5 | 18/20 | ✅ |
| Zustand | 4/5 | 5/5 | 5/5 | 4/5 | 18/20 | ✅ |

**结论：** 对于中小型应用，推荐 Context API（内置，无额外依赖）或 Zustand（更简洁的 API）。

## 测试策略设计

### 测试金字塔

```
        /\
       /E2E\      ← 少量端到端测试（关键用户流程）
      /------\
     /集成测试\    ← 中等数量集成测试（模块交互）
    /----------\
   /  单元测试  \  ← 大量单元测试（函数、组件）
  /--------------\
```

### 测试覆盖率目标

根据代码类型设定不同的覆盖率目标：

| 代码类型 | 覆盖率目标 | 测试重点 |
|---------|-----------|---------|
| **业务逻辑** | 90%+ | 边缘情况、错误处理 |
| **UI 组件** | 80%+ | 用户交互、状态变化 |
| **工具函数** | 95%+ | 输入输出、异常情况 |
| **API 集成** | 70%+ | 请求/响应、错误处理 |
| **配置文件** | 0% | 无需测试 |

### 测试用例设计

对每个功能，设计测试用例：

```markdown
**功能：** 用户登录

**单元测试：**
- [ ] 验证邮箱格式正确
- [ ] 验证邮箱格式错误时显示错误
- [ ] 验证密码长度符合要求
- [ ] 验证 API 调用参数正确

**集成测试：**
- [ ] 登录成功后跳转到首页
- [ ] 登录失败显示错误提示
- [ ] 记住我功能保存登录状态

**E2E 测试：**
- [ ] 完整登录流程（输入 → 提交 → 跳转）
- [ ] 登录后访问受保护页面
```

## 迭代对话技巧

### 第1轮：澄清问题

**提问技巧：**
- 使用开放式问题：「你希望这个功能如何工作？」
- 询问边界条件：「如果用户输入无效数据会怎样？」
- 确认假设：「我假设使用 JWT 认证，这样可以吗？」
- 探索约束：「是否有性能或安全方面的特殊要求？」

**示例问题集：**
```markdown
1. 功能边界：
   - 这个功能的核心目标是什么？
   - 哪些是必须实现的，哪些是可选的？
   - 是否有明确不需要的功能？

2. 用户体验：
   - 用户如何触发这个功能？
   - 成功/失败时用户应该看到什么？
   - 是否需要加载状态或进度提示？

3. 技术约束：
   - 是否必须使用特定的库或框架？
   - 是否有性能要求（响应时间、并发量）？
   - 是否需要兼容特定浏览器或设备？
```

### 第2轮：细化方案

**细化检查清单：**
- [ ] 每个任务都有明确的输入和输出
- [ ] 每个任务都指定了具体的文件路径
- [ ] 任务之间的依赖关系已明确
- [ ] 每个任务的复杂度已评估（简单/中等/复杂）
- [ ] 识别了可以并行进行的任务

**任务描述模板：**
```markdown
**任务：** [任务名称]
**文件：** path/to/file.ts:line
**依赖：** [前置任务]
**复杂度：** 简单/中等/复杂
**描述：** [具体要做什么]
**输入：** [需要什么数据/状态]
**输出：** [产生什么结果]
**测试：** [如何验证完成]
```

### 第3轮：讨论权衡

**权衡分析模板：**
```markdown
## 方案对比：[决策点]

### 方案 A：[名称]
**优点：**
- ✅ [优点1]
- ✅ [优点2]

**缺点：**
- ❌ [缺点1]
- ❌ [缺点2]

**适用场景：** [什么情况下选择此方案]

### 方案 B：[名称]
...

### 推荐方案：[A/B]
**理由：** [为什么推荐这个方案]
**权衡：** [接受了哪些缺点，为什么可以接受]
```

### 第4轮：补充边缘情况

**边缘情况检查清单：**

**错误处理：**
- [ ] 网络请求失败
- [ ] 数据格式错误
- [ ] 权限不足
- [ ] 资源不存在
- [ ] 并发冲突

**性能考虑：**
- [ ] 大数据量处理
- [ ] 频繁操作优化
- [ ] 缓存策略
- [ ] 懒加载/按需加载

**安全考虑：**
- [ ] 输入验证和清理
- [ ] XSS 防护
- [ ] CSRF 防护
- [ ] 敏感数据加密
- [ ] 权限检查

### 第5轮：最终审查

**审查检查清单：**

**完整性：**
- [ ] 所有需求都有对应的实施步骤
- [ ] 所有边缘情况都有处理方案
- [ ] 所有风险都有缓解措施
- [ ] 测试策略覆盖所有关键路径

**可执行性：**
- [ ] 每个步骤都是具体的、可操作的
- [ ] 没有模糊或抽象的描述
- [ ] 所有文件路径都是真实存在的
- [ ] 所有依赖关系都是可行的

**合理性：**
- [ ] 实施顺序符合逻辑
- [ ] 没有循环依赖
- [ ] 复杂度评估合理
- [ ] 技术方案可行

## 计划文档结构

### 标准计划模板

```markdown
# [功能名称] 实施计划

**创建时间：** YYYY-MM-DD HH:mm
**最后更新：** YYYY-MM-DD HH:mm
**状态：** 草稿/审查中/已批准/实施中/已完成
**复杂度：** 简单/中等/复杂
**预估工作量：** [可选]

## 1. 需求概述

### 1.1 背景
[为什么需要这个功能]

### 1.2 目标
[这个功能要达成什么目标]

### 1.3 范围
**包含：**
- [功能1]
- [功能2]

**不包含：**
- [明确不做的事情]

### 1.4 成功标准
- [ ] [如何判断功能完成]
- [ ] [如何判断功能成功]

## 2. 技术方案

### 2.1 整体架构
[架构图或文字描述]

### 2.2 技术选型
| 技术点 | 选择 | 理由 |
|-------|------|------|
| 状态管理 | Context API | 应用规模小，无需 Redux |
| UI 库 | MUI | 项目已使用 |

### 2.3 数据模型
```typescript
interface User {
  id: string;
  email: string;
  // ...
}
```

### 2.4 API 设计
```
POST /api/auth/login
Request: { email, password }
Response: { token, user }
```

## 3. 实施步骤

### 阶段 1：基础设施 (1-2天)
- [ ] 创建数据模型 (models/user.ts)
- [ ] 设置 API 路由 (api/auth/login.ts)
- [ ] 配置环境变量 (.env.local)

**依赖：** 无
**风险：** 低

### 阶段 2：核心功能 (2-3天)
- [ ] 实现登录表单组件 (components/LoginForm.tsx)
- [ ] 实现认证逻辑 (hooks/useAuth.ts)
- [ ] 集成 API 调用 (api/client.ts)

**依赖：** 阶段 1
**风险：** 中

### 阶段 3：测试和优化 (1-2天)
- [ ] 编写单元测试
- [ ] 编写集成测试
- [ ] 性能优化
- [ ] 错误处理完善

**依赖：** 阶段 2
**风险：** 低

## 4. 风险评估

| 风险 | 概率 | 影响 | 优先级 | 缓解措施 |
|------|------|------|--------|---------|
| 第三方 API 不稳定 | 中 | 高 | 高 | 添加重试机制和降级方案 |
| 性能问题 | 低 | 中 | 中 | 提前进行性能测试 |

## 5. 测试策略

### 5.1 单元测试
**目标覆盖率：** 85%

**测试重点：**
- 表单验证逻辑
- 认证状态管理
- API 调用参数

### 5.2 集成测试
**测试场景：**
- 登录成功流程
- 登录失败处理
- Token 刷新机制

### 5.3 E2E 测试
**关键路径：**
- 用户登录 → 访问受保护页面 → 登出

## 6. 技术权衡

### 6.1 状态管理：Context API vs Redux
**决策：** 选择 Context API
**理由：**
- 应用规模较小，Redux 过于复杂
- Context API 是 React 内置，无额外依赖
- 团队对 Context API 更熟悉

**权衡：**
- 接受：Context API 在大规模应用中可能有性能问题
- 缓解：如果未来应用扩大，可以迁移到 Redux

### 6.2 认证方式：JWT vs Session
**决策：** 选择 JWT
**理由：**
- 无状态，易于扩展
- 支持跨域
- 移动端友好

## 7. 回滚计划

### 7.1 回滚触发条件
- 关键功能无法正常工作
- 性能严重下降（>50%）
- 安全漏洞被发现

### 7.2 回滚步骤
1. 停止新功能的流量
2. 恢复到上一个稳定版本
3. 通知相关人员
4. 分析问题原因

### 7.3 数据回滚
- 数据库迁移脚本的回滚版本
- 数据备份恢复流程

## 8. 后续工作

### 8.1 已知限制
- [当前版本的限制]

### 8.2 未来改进
- [可以改进的地方]

### 8.3 相关任务
- [依赖此功能的其他任务]

## 9. 参考资料

- [相关文档链接]
- [技术文档链接]
- [设计稿链接]

## 10. 变更记录

| 日期 | 变更内容 | 变更人 |
|------|---------|--------|
| 2024-01-01 | 初始版本 | Claude |
| 2024-01-02 | 添加错误处理 | Claude |
```

## 常见陷阱和解决方案

### 陷阱 1：计划过于抽象

**问题：** 「实现用户认证」太抽象，无法执行

**解决：** 分解为具体任务
```
❌ 实现用户认证
✅ 创建登录表单组件 (components/LoginForm.tsx)
✅ 实现表单验证逻辑 (utils/validation.ts)
✅ 调用登录 API (api/auth.ts)
✅ 保存认证 token (hooks/useAuth.ts)
```

### 陷阱 2：忽略依赖关系

**问题：** 任务顺序混乱，导致阻塞

**解决：** 绘制依赖图，确定关键路径
```
A → B → D  (关键路径，必须串行)
A → C      (可与 B 并行)
```

### 陷阱 3：低估风险

**问题：** 未识别潜在风险，导致延期

**解决：** 使用风险识别矩阵，系统性评估

### 陷阱 4：测试策略缺失

**问题：** 实现完成后才考虑测试，导致返工

**解决：** 在计划阶段就设计测试策略，遵循 TDD

### 陷阱 5：缺乏用户参与

**问题：** 闭门造车，最终方案不符合需求

**解决：** 多轮迭代，每轮都获取用户反馈

## MoSCoW 方法详解

### 什么是 MoSCoW？

MoSCoW 是一种优先级排序方法，用于明确功能范围和防止范围蔓延：

- **Must Have（必须实现）** - 核心功能，没有它项目无法成功
- **Should Have（应该实现）** - 重要功能，但不是关键
- **Could Have（可以实现）** - 锦上添花的功能
- **Won't Have（不实现）** - 明确不在本次范围内的功能

### 如何使用 MoSCoW 矩阵

**步骤1：列出所有功能**

将用户提到的所有功能列出来，不做判断。

**步骤2：逐个分类**

对每个功能提问：
- 如果没有这个功能，项目能成功吗？→ Must Have
- 这个功能很重要，但可以延后吗？→ Should Have
- 这个功能是额外的好处吗？→ Could Have
- 这个功能超出当前范围吗？→ Won't Have

**步骤3：验证 Must Have**

确保 Must Have 列表中的功能确实是必需的：
- 如果移除这个功能，用户能完成核心任务吗？
- 这个功能是否可以用更简单的方式实现？

**步骤4：与用户确认**

使用 AskUserQuestion 工具，让用户确认优先级划分。

### 优先级判断标准

| 类别 | 判断标准 | 示例 |
|------|---------|------|
| **Must Have** | 核心价值、用户必需、法律要求 | 用户登录、数据保存、支付功能 |
| **Should Have** | 重要但非关键、提升体验 | 记住我、头像上传、搜索历史 |
| **Could Have** | 锦上添花、未来扩展 | 深色模式、快捷键、动画效果 |
| **Won't Have** | 超出范围、技术限制、低价值 | 第三方登录、多语言、离线模式 |

### 范围变更控制流程

当用户在实施过程中提出新需求时：

1. **评估影响**
   - 这个需求属于哪个类别？
   - 实现它需要多少工作量？
   - 会影响哪些已有功能？

2. **重新排序**
   - 如果是 Must Have，需要移除其他功能吗？
   - 如果是 Should Have，可以延后到下个版本吗？

3. **更新计划**
   - 更新 MoSCoW 矩阵
   - 更新实施步骤
   - 重新评估风险

---

## 5层次需求框架详解

### 为什么需要5层次框架？

传统的需求澄清往往只关注"做什么"（What），忽略了"为什么"（Why）和"怎么做"（How）。5层次框架确保全面理解需求。

### 第1层：核心目标（Why）

**目的：** 理解需求背后的动机和价值

**关键问题：**
1. 为什么需要这个功能？
   - 解决什么问题？
   - 用户的痛点是什么？
   - 不做这个功能会怎样？

2. 成功标准是什么？
   - 如何衡量成功？
   - 关键指标是什么？（如：转化率、响应时间、用户满意度）

3. 对用户/业务的价值是什么？
   - 用户能获得什么好处？
   - 业务能获得什么收益？

**示例对话：**
```
用户：我需要添加一个搜索功能
Claude：为什么需要搜索功能？用户遇到了什么问题？
用户：用户反馈说找不到历史订单
Claude：成功的标准是什么？用户能在多少时间内找到订单？
用户：希望用户能在5秒内找到任何历史订单
```

### 第2层：功能范围（What）

**目的：** 明确要做什么，不做什么

**关键问题：**
1. 核心功能是什么？
   - 最小可行功能（MVP）是什么？
   - 核心用例有哪些？

2. 使用 MoSCoW 分类：
   - Must Have：必须实现的功能
   - Should Have：应该实现的功能
   - Could Have：可以实现的功能
   - Won't Have：明确不做的功能

**示例对话：**
```
Claude：搜索功能的核心是什么？
用户：用户能通过订单号、商品名、日期搜索订单
Claude：是否需要高级搜索（多条件组合）？
用户：不需要，简单搜索就够了
Claude：那我们把高级搜索放到 Won't Have 类别
```

### 第3层：用户体验（How）

**目的：** 理解用户如何使用这个功能

**关键问题：**
1. 用户如何触发这个功能？
   - 在哪个页面？
   - 通过什么操作？（点击、输入、快捷键）

2. 成功/失败时用户看到什么？
   - 成功：显示结果、跳转页面、提示消息？
   - 失败：错误提示、建议操作、联系支持？

3. 是否需要加载状态、进度提示、错误提示？
   - 搜索需要多长时间？
   - 是否需要显示"正在搜索..."？
   - 没有结果时显示什么？

4. 是否需要确认对话框或撤销功能？
   - 操作是否可逆？
   - 是否需要二次确认？

**示例对话：**
```
Claude：用户在哪里触发搜索？
用户：在订单列表页面的顶部有一个搜索框
Claude：搜索结果如何显示？
用户：在当前页面直接过滤订单列表
Claude：如果没有结果怎么办？
用户：显示"未找到订单"，并提供清除搜索的按钮
```

### 第4层：技术约束（Constraints）

**目的：** 识别技术限制和要求

**关键问题：**
1. 性能要求：
   - 响应时间要求？（如：搜索结果在1秒内返回）
   - 并发量要求？（如：支持1000个并发搜索）
   - 数据量要求？（如：搜索10万条订单）

2. 安全要求：
   - 涉及敏感数据吗？（如：用户隐私、支付信息）
   - 需要加密吗？（如：传输加密、存储加密）
   - 需要权限控制吗？（如：只能搜索自己的订单）

3. 兼容性：
   - 需要支持哪些浏览器？（如：Chrome、Firefox、Safari）
   - 需要支持移动端吗？（如：响应式设计、原生应用）
   - 需要支持旧版本吗？（如：IE11）

4. 依赖限制：
   - 必须使用特定库吗？（如：公司标准库）
   - 必须调用特定 API 吗？（如：现有搜索服务）
   - 有技术债务需要考虑吗？（如：旧代码兼容）

**示例对话：**
```
Claude：搜索性能有要求吗？
用户：希望在1秒内返回结果
Claude：数据量有多大？
用户：目前有5万条订单，预计增长到20万
Claude：是否需要权限控制？
用户：是的，用户只能搜索自己的订单
```

### 第5层：边界情况（Edge Cases）

**目的：** 提前识别异常情况

**关键问题：**
1. 网络请求失败怎么办？
   - 超时、断网、服务器错误

2. 数据不存在怎么办？
   - 空结果、数据被删除、数据格式错误

3. 用户权限不足怎么办？
   - 未登录、Token 过期、权限不足

4. 并发冲突怎么办？
   - 重复提交、数据冲突、竞态条件

5. 用户输入无效数据怎么办？
   - 空输入、特殊字符、超长输入

**示例对话：**
```
Claude：如果搜索超时怎么办？
用户：显示错误提示，允许用户重试
Claude：如果用户输入特殊字符怎么办？
用户：需要过滤特殊字符，防止 SQL 注入
Claude：如果用户快速连续搜索怎么办？
用户：使用防抖，避免频繁请求
```

### 如何组织问题以提高效率

**方法1：使用 AskUserQuestion 的多问题功能**

一次性提出2-3个相关问题，而不是逐个提问：

```typescript
AskUserQuestion({
  questions: [
    {
      header: "核心目标",
      question: "为什么需要这个功能？解决什么问题？",
      options: [...]
    },
    {
      header: "功能范围",
      question: "哪些功能是必须实现的（Must Have）？",
      options: [...]
    },
    {
      header: "技术约束",
      question: "是否有性能或安全方面的特殊要求？",
      options: [...]
    }
  ]
})
```

**方法2：分组相关问题**

将5层次问题分为2-3组：

**第1组：目标和范围（Why + What）**
- 为什么需要这个功能？
- 核心功能是什么？
- 哪些是必须的，哪些是可选的？

**第2组：体验和约束（How + Constraints）**
- 用户如何使用？
- 有什么技术限制？

**第3组：边界情况（Edge Cases）**
- 异常情况如何处理？

### 常见陷阱和解决方案

**陷阱1：只问 What，不问 Why**

❌ 错误：直接问"需要哪些功能？"
✅ 正确：先问"为什么需要这个功能？解决什么问题？"

**陷阱2：假设用户知道所有细节**

❌ 错误：假设用户已经考虑了所有边界情况
✅ 正确：主动提出边界情况，引导用户思考

**陷阱3：一次只问一个问题**

❌ 错误：逐个提问，导致反复对话
✅ 正确：使用结构化多问题，一次收集更多信息

---

## 边界情况矩阵详解

### 为什么需要边界情况矩阵？

传统的边界情况处理往往是临时性的、不系统的。边界情况矩阵提供了一个结构化的框架，确保全面覆盖。

### 4个维度详解

#### 1. 数据维度

关注数据的各种状态和异常情况。

| 场景 | 触发条件 | 处理方案 | 测试用例 | 优先级 |
|------|---------|---------|---------|--------|
| 数据为空 | 查询返回 null/undefined | 显示占位符或空状态提示 | test_empty_data | 高 |
| 数据超大 | 数据量 >10000 条 | 分页加载或虚拟滚动 | test_large_data | 中 |
| 数据格式错误 | 字段类型不匹配 | 验证+降级显示 | test_invalid_format | 高 |
| 数据部分缺失 | 某些字段为空 | 使用默认值或隐藏字段 | test_partial_data | 中 |
| 数据重复 | 主键冲突 | 去重或提示用户 | test_duplicate_data | 中 |

**识别方法：**
- 数据可能为空吗？
- 数据可能很大吗？
- 数据格式可能错误吗？
- 数据可能部分缺失吗？

#### 2. 网络维度

关注网络请求的各种失败情况。

| 场景 | 触发条件 | 处理方案 | 测试用例 | 优先级 |
|------|---------|---------|---------|--------|
| 网络超时 | 请求 >10s 无响应 | 重试3次，显示错误提示 | test_timeout | 高 |
| 网络断开 | 无网络连接 | 显示离线提示，缓存数据 | test_offline | 中 |
| 服务器错误 | 5xx 响应 | 显示错误提示，记录日志 | test_server_error | 高 |
| 客户端错误 | 4xx 响应 | 显示具体错误信息 | test_client_error | 高 |
| 慢网络 | 请求 >3s | 显示加载状态 | test_slow_network | 中 |

**识别方法：**
- 网络可能超时吗？
- 网络可能断开吗？
- 服务器可能返回错误吗？
- 网络可能很慢吗？

#### 3. 并发维度

关注多个操作同时进行的情况。

| 场景 | 触发条件 | 处理方案 | 测试用例 | 优先级 |
|------|---------|---------|---------|--------|
| 重复提交 | 用户快速点击 | 防抖/节流/禁用按钮 | test_duplicate_submit | 高 |
| 数据冲突 | 并发修改同一数据 | 乐观锁/悲观锁 | test_concurrent_update | 中 |
| 竞态条件 | 异步操作顺序错乱 | 取消前置请求/使用序列号 | test_race_condition | 中 |
| 资源竞争 | 多个操作争用资源 | 队列/锁机制 | test_resource_contention | 低 |

**识别方法：**
- 用户可能快速点击吗？
- 多个用户可能同时修改数据吗？
- 异步操作可能顺序错乱吗？

#### 4. 权限维度

关注用户权限和认证相关的情况。

| 场景 | 触发条件 | 处理方案 | 测试用例 | 优先级 |
|------|---------|---------|---------|--------|
| 未登录 | 用户未认证 | 跳转登录页 | test_unauthenticated | 高 |
| 权限不足 | 用户无访问权限 | 显示403错误 | test_forbidden | 高 |
| Token 过期 | Token 失效 | 自动刷新或跳转登录 | test_token_expired | 高 |
| 会话失效 | 会话超时 | 清除状态，跳转登录 | test_session_invalid | 高 |
| 跨域访问 | 不同域名访问 | CORS 配置 | test_cors | 中 |

**识别方法：**
- 用户可能未登录吗？
- 用户可能权限不足吗？
- Token 可能过期吗？

### 如何识别边界情况

**方法1：反向思考**

对每个正常流程，问"如果...会怎样？"

正常流程：用户点击搜索 → 发送请求 → 返回结果 → 显示列表

反向思考：
- 如果网络断开会怎样？→ 网络维度
- 如果返回空结果会怎样？→ 数据维度
- 如果用户快速点击会怎样？→ 并发维度
- 如果用户未登录会怎样？→ 权限维度

**方法2：使用检查清单**

对每个功能，逐个检查4个维度：

```markdown
## 边界情况检查清单

### 数据维度
- [ ] 数据为空
- [ ] 数据超大
- [ ] 数据格式错误
- [ ] 数据部分缺失

### 网络维度
- [ ] 网络超时
- [ ] 网络断开
- [ ] 服务器错误
- [ ] 慢网络

### 并发维度
- [ ] 重复提交
- [ ] 数据冲突
- [ ] 竞态条件

### 权限维度
- [ ] 未登录
- [ ] 权限不足
- [ ] Token 过期
```

### 如何设计处理方案

**原则1：优雅降级**

当功能无法正常工作时，提供降级方案：

- 网络断开 → 显示缓存数据
- 图片加载失败 → 显示占位图
- 搜索失败 → 显示历史搜索

**原则2：明确反馈**

让用户知道发生了什么：

- 加载中 → 显示加载动画
- 失败 → 显示错误信息和重试按钮
- 成功 → 显示成功提示

**原则3：防御性编程**

假设一切都可能出错：

```typescript
// ❌ 不安全
const name = user.profile.name;

// ✅ 安全
const name = user?.profile?.name ?? '未知用户';
```

### 如何关联测试用例

每个边界情况都应该有对应的测试用例：

```markdown
| 场景 | 处理方案 | 测试用例 | 测试步骤 |
|------|---------|---------|---------|
| 数据为空 | 显示占位符 | test_empty_data | 1. Mock 空数据<br>2. 验证显示占位符 |
| 网络超时 | 重试3次 | test_timeout | 1. Mock 超时<br>2. 验证重试3次<br>3. 验证错误提示 |
```

---

## 高效对话技巧

### 为什么需要高效对话？

传统的逐个提问方式效率低下，导致反复对话。高效对话技巧可以：
- 减少对话轮次
- 提高信息密度
- 避免反复确认

### 技巧1：使用结构化多问题

**传统方式（低效）：**
```
Claude：为什么需要这个功能？
用户：解决用户找不到订单的问题
Claude：核心功能是什么？
用户：搜索订单
Claude：有性能要求吗？
用户：希望1秒内返回结果
```
需要3轮对话。

**高效方式：**
```
Claude：让我通过几个问题了解需求：
1. 为什么需要这个功能？解决什么问题？
2. 核心功能是什么？哪些是必须的？
3. 有性能或安全方面的特殊要求吗？

用户：[一次性回答所有问题]
```
只需1轮对话。

### 技巧2：分组相关问题

将相关问题分组，一次性提出：

**第1组：目标和范围**
- 为什么需要这个功能？
- 核心功能是什么？
- 哪些是必须的，哪些是可选的？

**第2组：体验和约束**
- 用户如何使用？
- 有什么技术限制？

**第3组：边界情况**
- 异常情况如何处理？

### 技巧3：使用 AskUserQuestion 的多问题功能

```typescript
AskUserQuestion({
  questions: [
    {
      header: "核心目标",
      question: "为什么需要这个功能？",
      options: [
        { label: "解决用户痛点", description: "用户反馈的问题" },
        { label: "业务需求", description: "公司战略要求" },
        { label: "技术升级", description: "替换旧系统" }
      ],
      multiSelect: false
    },
    {
      header: "功能范围",
      question: "哪些功能是必须实现的？",
      options: [
        { label: "基础搜索", description: "按关键词搜索" },
        { label: "高级搜索", description: "多条件组合" },
        { label: "搜索历史", description: "保存搜索记录" }
      ],
      multiSelect: true
    }
  ]
})
```

### 技巧4：提供选项而非开放式问题

**低效（开放式）：**
```
Claude：你希望如何处理网络超时？
用户：嗯...我不太确定...可能重试？
Claude：重试几次？
用户：3次吧
```

**高效（提供选项）：**
```
Claude：网络超时时如何处理？
选项：
A. 重试3次，然后显示错误
B. 立即显示错误，允许用户手动重试
C. 使用缓存数据，后台重试

用户：选A
```

### 技巧5：合并相关确认

**低效（多次确认）：**
```
Claude：你同意这个技术方案吗？
用户：同意
Claude：你同意这个实施步骤吗？
用户：同意
Claude：你同意这个测试策略吗？
用户：同意
```

**高效（一次确认）：**
```
Claude：请确认以下内容：
- 技术方案：使用 Context API
- 实施步骤：分3个阶段
- 测试策略：单元测试覆盖率85%+

你同意以上所有内容吗？
用户：同意
```

### 技巧6：提前说明预期

告诉用户接下来会问什么，让用户有心理准备：

```
Claude：我将通过3轮对话帮你制定计划：
第1轮：深度理解需求（5层次框架）
第2轮：设计技术方案和实施步骤
第3轮：评估风险和测试策略

现在开始第1轮，让我通过几个问题了解需求...
```

### 技巧7：避免不必要的确认

**不必要的确认：**
```
Claude：我理解了你的需求，对吗？
用户：对
Claude：那我开始制定计划，可以吗？
用户：可以
```

**直接行动：**
```
Claude：基于你的需求，我开始制定计划...
[直接输出计划]
```

### 技巧8：使用总结代替确认

**低效（逐项确认）：**
```
Claude：功能1是必须的，对吗？
用户：对
Claude：功能2是可选的，对吗？
用户：对
```

**高效（总结确认）：**
```
Claude：根据你的回答，我理解为：
- Must Have：功能1、功能2
- Should Have：功能3
- Won't Have：功能4

这样理解正确吗？
用户：正确
```

---

## 总结

有效的计划制定需要：
1. **结构化方法** - 使用成熟的框架和模板（5层次框架、MoSCoW、边界情况矩阵）
2. **迭代细化** - 通过多轮对话逐步完善（3-5轮灵活调整）
3. **风险意识** - 提前识别和缓解风险
4. **用户参与** - 让用户参与关键决策（仅关键点确认）
5. **文档驱动** - 维护清晰的书面计划
6. **可执行性** - 确保每个步骤都可操作
7. **高效对话** - 减少反复对话，提高信息密度

通过遵循这些最佳实践，可以创建高质量、可执行的实施计划，为项目成功奠定基础。
